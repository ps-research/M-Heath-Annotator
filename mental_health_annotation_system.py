# -*- coding: utf-8 -*-
"""Mental_Health_Annotation_System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zm829RWd5OLXxcc0S0AYaL6lJ5LNk-xq

# ════════════════════════════════════════════════
# MENTAL HEALTH ANNOTATION SYSTEM - MULTI-DOMAIN
# ═════════════════════════════════════════════════
#
# **Purpose:** Annotate mental health dataset across 6 domains
#
# **Domains:**
1.  Urgency Level (0-4)
2.  Therapeutic Approach (TA-1 to TA-9, multi-label)
3.  Intervention Intensity (INT-1 to INT-5, ordinal)
4.  Adjunct Services (ADJ-1 to ADJ-8, multi-label)
5.  Treatment Modality (MOD-1 to MOD-6, multi-label)
6.  Redressal Points (subjective list extraction)
#
# **Features:**
0.   Row-level checkpointing (resume from crash)

1.   Detailed malform logging (JSON tracking)
2.   Separate Google Sheet per annotator
3.   Domain-first processing (all samples → Domain 1 → all samples → Domain 2...)
4.   Strict << >> parsing with validation
5.   Progress tracking with TQDM


#
# ════════════════════════════════════════════════

# ─────────────────────────────────────────────
# CELL 1: CONFIGURATION
# ─────────────────────────────────────────────
"""

# ═══════════════════════════════════════════════════════════
# ANNOTATOR CONFIGURATION
# ═══════════════════════════════════════════════════════════

# CHANGE THIS FOR EACH GOOGLE ACCOUNT
ANNOTATOR_ID = 1  # Valid values: 1, 2, 3, 4, 5

# ═══════════════════════════════════════════════════════════
# PATHS & SETTINGS
# ═══════════════════════════════════════════════════════════

# Google Drive paths
DRIVE_ROOT = "/content/drive/MyDrive/MH_Annotations"
CHECKPOINT_DIR = f"{DRIVE_ROOT}/checkpoints"
MALFORM_LOG_DIR = f"{DRIVE_ROOT}/malform_logs"

# Source spreadsheet (original dataset)
SOURCE_SPREADSHEET_NAME = "M-Help Dataset"

# Output spreadsheet (will be created)
OUTPUT_SPREADSHEET_NAME = f"M-Help Annotations - Annotator {ANNOTATOR_ID}"

# Domain processing order
DOMAINS = [
    "Urgency",
    "Therapeutic",
    "Intensity",
    "Adjunct",
    "Modality",
    "Redressal"
]

# Model configuration
MODEL_NAME = "gemma-3-27b-it"

# Processing settings
RETRY_ON_ERROR = False  # Set to True if you want to retry failed samples
MAX_RETRIES = 1

print("✅ Configuration loaded!")
print(f"   Annotator ID: {ANNOTATOR_ID}")
print(f"   Output Spreadsheet: {OUTPUT_SPREADSHEET_NAME}")
print(f"   Domains to process: {', '.join(DOMAINS)}")

"""# ──────────────────────────────────────────────
# CELL 2: SETUP & INSTALLATIONS
# ───────────────────────────────────────────────
"""

# Install required packages
!pip install -U -q google-genai gspread google-auth google-auth-oauthlib google-auth-httplib2 tqdm

import os
import json
import re
import time
from datetime import datetime
from pathlib import Path
import pandas as pd
from tqdm.notebook import tqdm

# Google libraries
from google import genai
from google.genai import types
import gspread
from google.auth import default
from google.colab import auth
from google.colab import drive
from google.colab import userdata
from google.colab import drive

print("✅ Packages installed and imported!")

"""# ──────────────────────────────────────────────
# CELL 3: GOOGLE AUTHENTICATION
# ──────────────────────────────────────────────
"""

# Mount Google Drive
drive.mount('/content/drive')

# Create directories if they don't exist
os.makedirs(CHECKPOINT_DIR, exist_ok=True)
os.makedirs(MALFORM_LOG_DIR, exist_ok=True)

# Authenticate for Google Sheets
auth.authenticate_user()
creds, _ = default()
gc = gspread.authorize(creds)

os.environ["GEMINI_API_KEY"] = userdata.get("GOOGLE_API_KEY")

# Set Gemini API key from environment
# You should have already set this: os.environ["GEMINI_API_KEY"] = "your_key_here"
if "GEMINI_API_KEY" not in os.environ:
    print("⚠️  WARNING: GEMINI_API_KEY not set!")
    print("   Please run: os.environ['GEMINI_API_KEY'] = 'your_api_key_here'")
else:
    print("✅ Google Drive mounted!")
    print("✅ Google Sheets authenticated!")
    print("✅ Gemini API key found!")

"""# ────────────────────────────────────────────
# CELL 4: CHECKPOINT MANAGER
# ─────────────────────────────────────────────
"""

class CheckpointManager:
    """
    Manages checkpoint state for resumable annotation process.

    Checkpoint format:
    {
        "annotator_id": 1,
        "last_updated": "2025-01-26T10:30:00",
        "completed": {
            "Urgency": ["ID-1", "ID-2", "ID-3"],
            "Therapeutic": ["ID-1"]
        }
    }
    """

    def __init__(self, annotator_id):
        self.annotator_id = annotator_id
        self.checkpoint_path = f"{CHECKPOINT_DIR}/annotator_{annotator_id}_checkpoint.json"
        self.checkpoint = self._load()

    def _load(self):
        """Load checkpoint from file, or create new if doesn't exist"""
        if os.path.exists(self.checkpoint_path):
            with open(self.checkpoint_path, 'r') as f:
                checkpoint = json.load(f)
                print(f"✅ Loaded checkpoint for Annotator {self.annotator_id}")
                return checkpoint
        else:
            print(f"📝 Creating new checkpoint for Annotator {self.annotator_id}")
            return {
                "annotator_id": self.annotator_id,
                "last_updated": datetime.now().isoformat(),
                "completed": {domain: [] for domain in DOMAINS}
            }

    def is_completed(self, domain, sample_id):
        """Check if a sample is already annotated for a domain"""
        return sample_id in self.checkpoint["completed"].get(domain, [])

    def mark_completed(self, domain, sample_id):
        """Mark a sample as completed for a domain"""
        if domain not in self.checkpoint["completed"]:
            self.checkpoint["completed"][domain] = []

        if sample_id not in self.checkpoint["completed"][domain]:
            self.checkpoint["completed"][domain].append(sample_id)

    def save(self):
        """Save checkpoint to file"""
        self.checkpoint["last_updated"] = datetime.now().isoformat()
        with open(self.checkpoint_path, 'w') as f:
            json.dump(self.checkpoint, f, indent=2)

    def get_progress(self, domain, total_samples):
        """Get progress for a domain"""
        completed = len(self.checkpoint["completed"].get(domain, []))
        return completed, total_samples

print("✅ CheckpointManager class defined")

"""# ─────────────────────────────────────────
# CELL 5: MALFORM LOGGER
# ─────────────────────────────────────────
"""

class MalformLogger:
    """
    Tracks malformed responses with detailed error information.

    Log format:
    {
        "sample_ID-123": {
            "domain": "Urgency",
            "timestamp": "2025-01-26T10:30:00",
            "sample_text": "...",
            "raw_response": "...",
            "parsing_error": "Could not find << >> tags",
            "validity_error": "Label 'LEVEL_5' not in valid range",
            "retry_count": 0
        }
    }
    """

    def __init__(self, annotator_id):
        self.annotator_id = annotator_id
        self.log_path = f"{MALFORM_LOG_DIR}/annotator_{annotator_id}_malforms.json"
        self.log = self._load()

    def _load(self):
        """Load existing log or create new"""
        if os.path.exists(self.log_path):
            with open(self.log_path, 'r') as f:
                return json.load(f)
        return {}

    def log_error(self, sample_id, domain, sample_text, raw_response,
                  parsing_error=None, validity_error=None, retry_count=0):
        """Log a malformed response with detailed tracking"""

        # Create unique key with domain
        key = f"{sample_id}_{domain}"

        self.log[key] = {
            "sample_id": sample_id,
            "domain": domain,
            "timestamp": datetime.now().isoformat(),
            "sample_text": sample_text[:500],  # First 500 chars
            "raw_response": raw_response,
            "parsing_error": parsing_error,
            "validity_error": validity_error,
            "retry_count": retry_count
        }

        self.save()

    def save(self):
        """Save log to file"""
        with open(self.log_path, 'w') as f:
            json.dump(self.log, f, indent=2)

    def get_summary(self):
        """Get summary of malformed responses"""
        if not self.log:
            return "No malformed responses logged."

        summary = f"Total malformed responses: {len(self.log)}\n"

        # Count by domain
        domain_counts = {}
        for entry in self.log.values():
            domain = entry["domain"]
            domain_counts[domain] = domain_counts.get(domain, 0) + 1

        summary += "\nBy domain:\n"
        for domain, count in sorted(domain_counts.items()):
            summary += f"  {domain}: {count}\n"

        return summary

print("✅ MalformLogger class defined")

"""# ──────────────────────────────────────────
# CELL 6: GOOGLE SHEETS HELPER
# ───────────────────────────────────────────
"""

class SheetsManager:
    """
    Manages Google Sheets operations:
    1. Copy source spreadsheet
    2. Create domain annotation sheets
    3. Write annotations
    """

    def __init__(self, gc, annotator_id):
        self.gc = gc
        self.annotator_id = annotator_id
        self.spreadsheet = None

    def setup_spreadsheet(self):
        """Create annotator spreadsheet (copy of source + domain sheets)"""

        print(f"\n🔄 Setting up spreadsheet for Annotator {self.annotator_id}...")

        # Check if already exists
        try:
            self.spreadsheet = self.gc.open(OUTPUT_SPREADSHEET_NAME)
            print(f"✅ Found existing spreadsheet: {OUTPUT_SPREADSHEET_NAME}")
        except:
            # Create new spreadsheet
            print(f"📝 Creating new spreadsheet: {OUTPUT_SPREADSHEET_NAME}")
            self.spreadsheet = self.gc.create(OUTPUT_SPREADSHEET_NAME)

        # Get source data
        print("📥 Loading source data...")
        source_ss = self.gc.open(SOURCE_SPREADSHEET_NAME)

        # Copy Train, Validation, Test sheets if they don't exist
        for sheet_name in ["Train", "Validation", "Test"]:
            try:
                self.spreadsheet.worksheet(sheet_name)
                print(f"  ✓ {sheet_name} sheet exists")
            except:
                print(f"  📋 Copying {sheet_name} sheet...")
                source_sheet = source_ss.worksheet(sheet_name)
                data = source_sheet.get_all_values()

                new_sheet = self.spreadsheet.add_worksheet(
                    title=sheet_name,
                    rows=len(data),
                    cols=len(data[0]) if data else 10
                )
                new_sheet.update(values=data, range_name='A1')

        # Create domain annotation sheets
        for domain in DOMAINS:
            sheet_name = f"{domain}_Annotations"
            try:
                self.spreadsheet.worksheet(sheet_name)
                print(f"  ✓ {sheet_name} exists")
            except:
                print(f"  📋 Creating {sheet_name}...")
                headers = ["ID", "Text", "Response", "Label", "Malformed_Flag"]
                new_sheet = self.spreadsheet.add_worksheet(
                    title=sheet_name,
                    rows=3000,  # Enough for all samples
                    cols=len(headers)
                )
                new_sheet.update(values=[headers], range_name='A1')

        # Delete default Sheet1 if exists
        try:
            default_sheet = self.spreadsheet.worksheet("Sheet1")
            self.spreadsheet.del_worksheet(default_sheet)
        except:
            pass

        print(f"\n✅ Spreadsheet setup complete!")
        print(f"   URL: {self.spreadsheet.url}")

        return self.spreadsheet

    def load_source_data(self):
        """Load all samples from Train + Validation + Test"""

        print("\n📥 Loading source data from all splits...")

        all_samples = []

        for split_name in ["Train", "Validation", "Test"]:
            sheet = self.spreadsheet.worksheet(split_name)
            data = sheet.get_all_values()

            if len(data) <= 1:
                continue

            headers = data[0]
            rows = data[1:]

            df = pd.DataFrame(rows, columns=headers)
            all_samples.append(df)

            print(f"  ✓ Loaded {len(df)} samples from {split_name}")

        combined_df = pd.concat(all_samples, ignore_index=True)

        print(f"\n✅ Total samples loaded: {len(combined_df)}")

        return combined_df

    def write_annotation(self, domain, sample_id, text, response, label, malformed_flag):
        """Write a single annotation to the domain sheet"""

        sheet_name = f"{domain}_Annotations"
        sheet = self.spreadsheet.worksheet(sheet_name)

        # Get all existing IDs to check if already exists
        existing_ids = sheet.col_values(1)[1:]  # Skip header

        if sample_id in existing_ids:
            # Update existing row
            row_index = existing_ids.index(sample_id) + 2  # +2 for header and 1-indexing
            sheet.update(values=[[sample_id, text, response, label, malformed_flag]],
                        range_name=f'A{row_index}')
        else:
            # Append new row
            sheet.append_row([sample_id, text, response, label, malformed_flag])

print("✅ SheetsManager class defined")

"""# ───────────────────────────────────────────
# CELL 7: PROMPT TEMPLATES FOR ALL 6 DOMAINS
# ────────────────────────────────────────────
"""

# ═══════════════════════════════════════════════════════════
# DOMAIN 1: URGENCY LEVEL (0-4)
# ═══════════════════════════════════════════════════════════

URGENCY_PROMPT_TEMPLATE = """You are an expert mental health triage specialist working with a university counseling service. Your role is to assess the URGENCY LEVEL of student mental health cases to prioritize counselor appointments.

═══════════════════════════════════════════════════════════
URGENCY LEVELS DEFINITION
═══════════════════════════════════════════════════════════

Level 4: CRITICAL - Immediate Intervention (Within 24 Hours)
• Active suicidal ideation WITH specific plan or intent
• Current self-harm behaviors (cutting, burning, etc.)
• Acute psychotic episode or severe dissociation
• Immediate danger to self or others
• Phrases like: "I'm going to kill myself", "tonight", "I have a plan", "goodbye"
→ ACTION: Emergency contact, crisis hotline, see TODAY

Level 3: URGENT - Priority Scheduling (Within 2-3 Days)
• Severe symptoms with MAJOR functional impairment
• Passive suicidal thoughts ("wish I was dead" but no plan)
• Severe anxiety/panic preventing daily activities (can't attend class, leave room)
• Multiple comorbid conditions with high distress
• Rapid deterioration of mental state
→ ACTION: Fast-track appointment, specialized counselor

Level 2: MODERATE - Standard Scheduling (Within 1-2 Weeks)
• Clear mental health symptoms needing professional help
• Functional impairment (struggling with studies/relationships)
• Persistent depression, anxiety, trauma symptoms (weeks/months)
• Should be in regular therapy but not emergency
→ ACTION: Standard appointment queue

Level 1: LOW - Can Wait / Group Sessions (Within 3-4 Weeks)
• Mild symptoms, early intervention beneficial
• Could benefit from brief counseling or group therapy
• Not currently in crisis, coping mostly intact
• Seeking support but managing day-to-day
→ ACTION: Group sessions, peer support, or individual when available

Level 0: SELF-HELP - No Counselor Needed
• General stress, exam anxiety (normal range)
• Seeking advice or validation
• Can manage with resources (apps, workshops, peer support)
• No indication of mental health condition
→ ACTION: Refer to self-help resources, psychoeducation

═══════════════════════════════════════════════════════════
ANNOTATION GUIDELINES - CRITICAL INSTRUCTIONS
═══════════════════════════════════════════════════════════

STEP 1: READ CAREFULLY
• Read the ENTIRE student text word by word
• Note every mention of: suicide, self-harm, crisis words, timeframes

STEP 2: ANALYZE SENTENCE BY SENTENCE
• For EACH sentence, identify:
  - Risk indicators (suicide, self-harm, danger)
  - Severity markers ("can't", "always", "never", "worst")
  - Temporal urgency ("tonight", "today", "right now")
  - Functional impairment (can't work, study, leave bed)
  - Duration (days vs weeks vs months)

STEP 3: CITE SPECIFIC PHRASES
• You MUST quote exact phrases from the text that justify your decision
• Use quotation marks: "exact phrase from text"
• For each level consideration, cite supporting evidence

STEP 4: DIFFERENTIATE BETWEEN LEVELS
• Level 4 vs 3: Does text mention SPECIFIC PLAN or just thoughts?
• Level 3 vs 2: Is functional impairment SEVERE (can't function) or MODERATE (struggling)?
• Level 2 vs 1: Are symptoms PERSISTENT (weeks+) or MILD/RECENT?
• Level 1 vs 0: Any indication of clinical distress vs normal stress?

STEP 5: CONSIDER RISK FACTORS
• Immediacy: "tonight", "today" = Level 4
• Specificity of plan: "I have pills" = Level 4
• Passive ideation: "wish I was dead" = Level 3
• Hopelessness + impairment = Level 3
• Chronic symptoms + struggling = Level 2
• Seeking support, coping = Level 1
• No distress indicators = Level 0

STEP 6: PROVIDE DETAILED REASONING
Write a comprehensive analysis covering:
1. Key phrases you identified (with quotes)
2. Risk level assessment
3. Functional impairment level
4. Why you ruled out other levels
5. Final decision with clear justification

STEP 7: OUTPUT FORMAT (STRICTLY REQUIRED)
End your response with the urgency level in this EXACT format:

<<LEVEL_X>>

Where X is 0, 1, 2, 3, or 4

═══════════════════════════════════════════════════════════
STUDENT TEXT TO ANALYZE
═══════════════════════════════════════════════════════════

{text}

═══════════════════════════════════════════════════════════
YOUR DETAILED ANALYSIS
═══════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════
# DOMAIN 2: THERAPEUTIC APPROACH (Multi-label: TA-1 to TA-9)
# ═══════════════════════════════════════════════════════════

THERAPEUTIC_PROMPT_TEMPLATE = """You are a clinical psychologist specializing in treatment planning. Your task is to identify which THERAPEUTIC APPROACHES would be beneficial for this student.

═══════════════════════════════════════════════════════════
THERAPEUTIC APPROACHES TAXONOMY
═══════════════════════════════════════════════════════════

TA-1: Cognitive Behavioral Therapy (CBT)
• Best for: GAD, MDD, OCD, panic disorder
• Focus: Identifying and changing negative thought patterns
• Indicators: Rumination, catastrophizing, black-and-white thinking, avoidance

TA-2: Dialectical Behavior Therapy (DBT)
• Best for: BPD, emotion dysregulation, self-harm, suicidal ideation
• Focus: Distress tolerance, emotional regulation, interpersonal effectiveness
• Indicators: Intense emotions, self-harm, impulsivity, unstable relationships

TA-3: Trauma-Focused Therapy (EMDR, CPT)
• Best for: PTSD, complex trauma, abuse survivors
• Focus: Processing traumatic memories, reducing trauma symptoms
• Indicators: Flashbacks, nightmares, trauma history, hypervigilance

TA-4: Interpersonal Therapy (IPT)
• Best for: MDD with relationship issues, grief, role transitions
• Focus: Improving interpersonal relationships and social functioning
• Indicators: Relationship conflicts, social isolation, grief, life transitions

TA-5: Acceptance and Commitment Therapy (ACT)
• Best for: GAD, MDD, chronic stress, existential concerns
• Focus: Psychological flexibility, mindfulness, values-based action
• Indicators: Avoidance behaviors, struggles with acceptance, lack of direction

TA-6: Family Systems Therapy
• Best for: Family conflict, cultural issues, developmental stages
• Focus: Family dynamics, communication patterns
• Indicators: Family conflict mentioned, cultural stressors, family involvement needed

TA-7: Psychoeducation
• Best for: All cases, especially new diagnoses
• Focus: Understanding condition, self-management, coping skills
• Indicators: Lack of understanding about mental health, seeking information

TA-8: Motivational Interviewing
• Best for: SUD, treatment resistance, ambivalence about change
• Focus: Building motivation, resolving ambivalence
• Indicators: Substance use, resistance to help, ambivalence

TA-9: Supportive Counseling
• Best for: Adjustment issues, life transitions, low distress
• Focus: Validation, emotional support, problem-solving
• Indicators: Life stressors, need for support, no specific disorder

═══════════════════════════════════════════════════════════
ANNOTATION GUIDELINES
═══════════════════════════════════════════════════════════

1. IDENTIFY INDICATORS: Quote phrases suggesting each approach
2. SELECT MULTIPLE: This is MULTI-LABEL - select ALL applicable therapies
3. PRIORITIZE: Mention which is PRIMARY vs ADJUNCT
4. CITE EVIDENCE: For each selected approach, quote supporting text
5. EXPLAIN EXCLUSIONS: Why certain approaches were NOT selected

CRITICAL DISTINCTIONS:
• CBT vs ACT: CBT changes thoughts, ACT accepts them
• DBT vs CBT: DBT for emotion dysregulation/self-harm, CBT for thought patterns
• Trauma therapy: Only if explicit trauma mentioned
• Psychoeducation: Almost always include for new/confused cases

OUTPUT FORMAT (STRICTLY REQUIRED):
End with selected approaches in this format:

<<TA-1, TA-3, TA-7>>

Use ONLY codes: TA-1, TA-2, TA-3, TA-4, TA-5, TA-6, TA-7, TA-8, TA-9
Separate multiple codes with commas
At least ONE approach must be selected

═══════════════════════════════════════════════════════════
STUDENT TEXT
═══════════════════════════════════════════════════════════

{text}

═══════════════════════════════════════════════════════════
YOUR ANALYSIS
═══════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════
# DOMAIN 3: INTERVENTION INTENSITY (Single-label: INT-1 to INT-5)
# ═══════════════════════════════════════════════════════════

INTENSITY_PROMPT_TEMPLATE = """You are a mental health treatment coordinator. Determine the appropriate INTENSITY of intervention needed.

═══════════════════════════════════════════════════════════
INTERVENTION INTENSITY LEVELS
═══════════════════════════════════════════════════════════

INT-1: Self-Guided Resources
• Apps (Headspace, Calm), workbooks, online modules
• Minimal or no professional involvement
• Indicators: Mild symptoms, high functioning, self-motivated

INT-2: Brief Intervention (1-3 sessions)
• Problem-focused, solution-oriented
• Specific issue with clear endpoint
• Indicators: Acute stressor, single issue, good coping skills

INT-3: Short-Term Therapy (6-12 sessions)
• Structured treatment protocol
• Weekly sessions over 2-3 months
• Indicators: Moderate symptoms, responsive to treatment, time-limited goals

INT-4: Long-Term Therapy (12+ sessions)
• Complex cases, multiple comorbidities
• Ongoing weekly sessions for months
• Indicators: Chronic issues, treatment resistance, complex trauma, personality disorders

INT-5: Intensive Outpatient Program
• Multiple sessions per week (3-5 days)
• Structured program with group + individual
• Indicators: Severe symptoms, high risk, needs intensive support

═══════════════════════════════════════════════════════════
DECISION CRITERIA
═══════════════════════════════════════════════════════════

Consider:
1. SEVERITY: How distressing are the symptoms?
2. CHRONICITY: Days vs weeks vs months vs years?
3. COMPLEXITY: Single issue vs multiple comorbidities?
4. FUNCTIONAL IMPAIRMENT: Mild impact vs severe disruption?
5. RISK LEVEL: Self-harm risk, suicide risk?
6. SUPPORT SYSTEM: Strong support vs isolated?
7. PRIOR TREATMENT: New case vs treatment-resistant?

CRITICAL DISTINCTIONS:
• INT-1 vs INT-2: Self-guided vs needs professional guidance
• INT-2 vs INT-3: Acute/specific vs ongoing/broader issues
• INT-3 vs INT-4: Moderate vs severe/complex
• INT-4 vs INT-5: Weekly sessions sufficient vs needs daily support

OUTPUT FORMAT:
End with intensity level in this format:

<<INT-X>>

Where X is 1, 2, 3, 4, or 5
ONLY ONE level must be selected

═══════════════════════════════════════════════════════════
STUDENT TEXT
═══════════════════════════════════════════════════════════

{text}

═══════════════════════════════════════════════════════════
YOUR ANALYSIS
═══════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════
# DOMAIN 4: ADJUNCT SERVICES (Multi-label: ADJ-1 to ADJ-8)
# ═══════════════════════════════════════════════════════════

ADJUNCT_PROMPT_TEMPLATE = """You are a mental health case coordinator. Identify ADJUNCT SERVICES (additional supports) needed alongside therapy.

═══════════════════════════════════════════════════════════
ADJUNCT SERVICES TAXONOMY
═══════════════════════════════════════════════════════════

ADJ-1: Psychiatric Consultation (Medication Evaluation)
• For: Severe depression, anxiety, psychosis, bipolar
• Indicators: Not responding to therapy alone, severe symptoms, mentions medication

ADJ-2: Medical Referral (Primary Care, Specialists)
• For: Sleep disorders, endocrine issues, neurological symptoms
• Indicators: Physical symptoms, fatigue, sleep issues, chronic pain

ADJ-3: Academic Accommodations
• For: Students with MH affecting studies
• Indicators: Can't attend class, struggling with deadlines, academic stress

ADJ-4: Peer Support Groups
• For: Shared experiences, reducing isolation
• Indicators: Loneliness, seeking connection, specific condition (LGBTQ+, grief)

ADJ-5: Crisis Hotline / Safety Planning
• For: Suicide risk, self-harm risk
• Indicators: Suicidal thoughts, crisis mentions, high risk

ADJ-6: Substance Use Treatment
• For: Alcohol/drug use disorders
• Indicators: Mentions substance use, addiction, struggling with use

ADJ-7: Nutritional Counseling
• For: Eating disorders
• Indicators: Anorexia, bulimia, body image issues, food restriction

ADJ-8: Occupational Therapy / Skills Training
• For: ASD, ADHD, developmental needs
• Indicators: Neurodevelopmental disorder, executive function issues

═══════════════════════════════════════════════════════════
ANNOTATION GUIDELINES
═══════════════════════════════════════════════════════════

1. SELECT ALL APPLICABLE: This is multi-label
2. QUOTE SUPPORTING EVIDENCE: For each selected service
3. PRIORITIZE: Which are ESSENTIAL vs RECOMMENDED?
4. NONE IS VALID: If no adjunct services needed, output <<NONE>>

OUTPUT FORMAT:
End with selected services:

<<ADJ-1, ADJ-3, ADJ-5>>

OR if none needed:

<<NONE>>

═══════════════════════════════════════════════════════════
STUDENT TEXT
═══════════════════════════════════════════════════════════

{text}

═══════════════════════════════════════════════════════════
YOUR ANALYSIS
═══════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════
# DOMAIN 5: TREATMENT MODALITY (Multi-label: MOD-1 to MOD-6)
# ═══════════════════════════════════════════════════════════

MODALITY_PROMPT_TEMPLATE = """You are a treatment planning specialist. Determine the appropriate TREATMENT MODALITY (format of therapy delivery).

═══════════════════════════════════════════════════════════
TREATMENT MODALITIES
═══════════════════════════════════════════════════════════

MOD-1: Individual Therapy
• One-on-one with therapist
• Indicators: Personal issues, need for privacy, deep work

MOD-2: Group Therapy
• Multiple clients, shared theme
• Indicators: Seeking connection, shared experience (depression, anxiety, grief)

MOD-3: Family Therapy
• Involves family members
• Indicators: Family conflict, communication issues, family-based trauma

MOD-4: Couples Therapy
• For romantic relationships
• Indicators: Relationship issues with partner, breakup distress

MOD-5: Online/Teletherapy
• Remote sessions
• Indicators: Transportation issues, preference for online, anxiety about in-person

MOD-6: Workshop / Skills Training
• Educational group format
• Indicators: Needs specific skills (stress management, social skills)

═══════════════════════════════════════════════════════════
DECISION CRITERIA
═══════════════════════════════════════════════════════════

1. MOST cases need MOD-1 (Individual) as primary
2. Add MOD-2 (Group) if loneliness or shared experience beneficial
3. MOD-3 (Family) only if family dynamics explicitly mentioned
4. MOD-4 (Couples) only if relationship distress with partner
5. MOD-5 (Online) if access barriers or explicit preference
6. MOD-6 (Workshop) as supplement for skills building

OUTPUT FORMAT:
End with selected modalities:

<<MOD-1, MOD-2>>

At least ONE modality must be selected

═══════════════════════════════════════════════════════════
STUDENT TEXT
═══════════════════════════════════════════════════════════

{text}

═══════════════════════════════════════════════════════════
YOUR ANALYSIS
═══════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════
# DOMAIN 6: REDRESSAL POINTS (Subjective extraction)
# ═══════════════════════════════════════════════════════════

REDRESSAL_PROMPT_TEMPLATE = """You are a mental health assessment specialist. Your task is to extract REDRESSAL POINTS - specific issues, concerns, or needs that require attention in therapy.

═══════════════════════════════════════════════════════════
WHAT ARE REDRESSAL POINTS?
═══════════════════════════════════════════════════════════

Redressal points are the CORE ISSUES that therapy should address. Think of them as:
• Specific problems needing resolution
• Sources of distress
• Skill deficits
• Relationship concerns
• Behavioral patterns to change
• Coping needs

═══════════════════════════════════════════════════════════
EXTRACTION GUIDELINES
═══════════════════════════════════════════════════════════

1. READ ENTIRE TEXT: Identify all mentions of problems/concerns

2. EXTRACT SPECIFIC POINTS:
   ✓ "Social anxiety affecting academic performance"
   ✓ "Trauma from childhood abuse"
   ✓ "Difficulty regulating emotions"
   ✓ "Lack of coping strategies for exam stress"
   ✓ "Family conflict causing distress"
   ✓ "Suicidal thoughts related to breakup"

   ✗ "Depression" (too vague - be specific about what aspect)
   ✗ "Mental health" (not specific)

3. BE DESCRIPTIVE BUT CONCISE:
   • Each point should be 5-15 words
   • Capture the essence of the problem
   • Link symptoms to impact when possible

4. ORGANIZE BY PRIORITY:
   • Most urgent/severe issues first
   • Secondary concerns later

5. TYPICAL COUNT: 3-7 points per case
   • Simple case: 2-3 points
   • Complex case: 5-8 points

═══════════════════════════════════════════════════════════
EXAMPLES
═══════════════════════════════════════════════════════════

Example 1:
Text: "I've been depressed since my breakup. I can't focus on studies and I'm failing classes."
Points:
• "Depression following romantic relationship breakup"
• "Academic performance decline due to depression"
• "Difficulty concentrating on studies"

Example 2:
Text: "I have panic attacks when I try to go to class. My family doesn't understand."
Points:
• "Panic attacks triggered by attending class"
• "Social anxiety preventing academic participation"
• "Lack of family understanding and support"

═══════════════════════════════════════════════════════════
OUTPUT FORMAT (STRICTLY REQUIRED)
═══════════════════════════════════════════════════════════

After your analysis, provide the list in this EXACT format:

<<["point 1", "point 2", "point 3"]>>

CRITICAL:
• Valid JSON array of strings
• Use double quotes for strings
• Each point in one line (no line breaks within strings)
• At least 2 points, maximum 10 points

═══════════════════════════════════════════════════════════
STUDENT TEXT
═══════════════════════════════════════════════════════════

{text}

═══════════════════════════════════════════════════════════
YOUR ANALYSIS
═══════════════════════════════════════════════════════════
"""

# ═══════════════════════════════════════════════════════════
# Combine all prompts into dictionary
# ═══════════════════════════════════════════════════════════

PROMPT_TEMPLATES = {
    "Urgency": URGENCY_PROMPT_TEMPLATE,
    "Therapeutic": THERAPEUTIC_PROMPT_TEMPLATE,
    "Intensity": INTENSITY_PROMPT_TEMPLATE,
    "Adjunct": ADJUNCT_PROMPT_TEMPLATE,
    "Modality": MODALITY_PROMPT_TEMPLATE,
    "Redressal": REDRESSAL_PROMPT_TEMPLATE
}

print("✅ All 6 domain prompt templates defined!")

"""# ─────────────────────────────────────────────────
# CELL 8: GEMINI CLIENT & RESPONSE PARSER
# ─────────────────────────────────────────────────
"""

class GeminiAnnotator:
    """
    Handles Gemini API calls and response parsing
    """

    def __init__(self):
        self.client = genai.Client(api_key=os.environ.get("GEMINI_API_KEY"))
        self.model = MODEL_NAME

    def generate(self, prompt):
        """
        Call Gemini API and return full response text
        """
        try:
            contents = [
                types.Content(
                    role="user",
                    parts=[types.Part.from_text(text=prompt)],
                )
            ]

            # Use streaming to get response
            response_text = ""
            for chunk in self.client.models.generate_content_stream(
                model=self.model,
                contents=contents,
                config=types.GenerateContentConfig()
            ):
              if chunk.text:
                  response_text += (chunk.text or "")

            return response_text

        except Exception as e:
            # Check if it's a rate limit error
            if "429" in str(e) or "quota" in str(e).lower() or "rate limit" in str(e).lower():
                print(f"\n⚠️  RATE LIMIT HIT: {str(e)}")
                print("   Daily quota exhausted. Saving checkpoint and exiting...")
                raise Exception("RATE_LIMIT_HIT")
            else:
                print(f"\n❌ API Error: {str(e)}")
                raise

    def parse_response(self, response_text, domain):
        """
        Parse response to extract answer from << >> tags

        Returns:
            (label, parsing_error, validity_error)
        """
        parsing_error = None
        validity_error = None
        label = None

        # Try to find << >> tags
        match = re.search(r'<<(.+?)>>', response_text, re.DOTALL)

        if not match:
            parsing_error = "Could not find << >> tags in response"
            return None, parsing_error, validity_error

        raw_label = match.group(1).strip()

        # Validate based on domain
        if domain == "Urgency":
            # Should be LEVEL_X where X is 0-4
            level_match = re.search(r'LEVEL[_\s]*([0-4])', raw_label, re.IGNORECASE)
            if level_match:
                label = f"LEVEL_{level_match.group(1)}"
            else:
                validity_error = f"Invalid urgency level format: {raw_label}"

        elif domain == "Therapeutic":
            # Should be comma-separated TA-X codes
            codes = re.findall(r'TA-([1-9])', raw_label)
            if codes:
                label = ", ".join([f"TA-{c}" for c in codes])
            else:
                validity_error = f"No valid TA codes found in: {raw_label}"

        elif domain == "Intensity":
            # Should be INT-X where X is 1-5
            int_match = re.search(r'INT-([1-5])', raw_label, re.IGNORECASE)
            if int_match:
                label = f"INT-{int_match.group(1)}"
            else:
                validity_error = f"Invalid intensity format: {raw_label}"

        elif domain == "Adjunct":
            # Should be comma-separated ADJ-X codes or NONE
            if "NONE" in raw_label.upper():
                label = "NONE"
            else:
                codes = re.findall(r'ADJ-([1-8])', raw_label)
                if codes:
                    label = ", ".join([f"ADJ-{c}" for c in codes])
                else:
                    validity_error = f"No valid ADJ codes found in: {raw_label}"

        elif domain == "Modality":
            # Should be comma-separated MOD-X codes
            codes = re.findall(r'MOD-([1-6])', raw_label)
            if codes:
                label = ", ".join([f"MOD-{c}" for c in codes])
            else:
                validity_error = f"No valid MOD codes found in: {raw_label}"

        elif domain == "Redressal":
            # Should be JSON array of strings
            try:
                # Try to parse as JSON
                points = json.loads(raw_label)
                if isinstance(points, list) and all(isinstance(p, str) for p in points):
                    label = json.dumps(points)  # Store as JSON string
                else:
                    validity_error = f"Invalid redressal format (not a list of strings): {raw_label}"
            except json.JSONDecodeError as e:
                validity_error = f"Invalid JSON in redressal points: {str(e)}"

        return label, parsing_error, validity_error

print("✅ GeminiAnnotator class defined")

"""# ──────────────────────────────────────────────────
# CELL 9: MAIN ANNOTATION FUNCTION
# ───────────────────────────────────────────────────
"""

def annotate_domain(domain, samples_df, checkpoint_mgr, malform_logger, sheets_mgr, gemini_client):
    """
    Annotate all samples for a single domain

    Args:
        domain: Domain name (e.g., "Urgency")
        samples_df: DataFrame with ID and Text columns
        checkpoint_mgr: CheckpointManager instance
        malform_logger: MalformLogger instance
        sheets_mgr: SheetsManager instance
        gemini_client: GeminiAnnotator instance
    """

    print(f"\n{'═'*70}")
    print(f"ANNOTATING DOMAIN: {domain}")
    print(f"{'═'*70}\n")

    # Get prompt template for this domain
    prompt_template = PROMPT_TEMPLATES[domain]

    # Get progress
    completed_count, total_count = checkpoint_mgr.get_progress(domain, len(samples_df))
    print(f"Progress: {completed_count}/{total_count} samples completed")

    if completed_count == total_count:
        print(f"✅ Domain '{domain}' already complete! Skipping...\n")
        return

    # Process each sample
    for idx, row in tqdm(samples_df.iterrows(), total=len(samples_df), desc=f"{domain}"):
        sample_id = row['ID']
        text = row['Text']

        # Skip if already completed
        if checkpoint_mgr.is_completed(domain, sample_id):
            continue

        # Build prompt
        prompt = prompt_template.format(text=text)

        try:
            # Generate response
            response = gemini_client.generate(prompt)

            # Parse response
            label, parsing_error, validity_error = gemini_client.parse_response(response, domain)

            # Check for errors
            malformed = (parsing_error is not None) or (validity_error is not None)

            if malformed:
                # Log malformed response
                malform_logger.log_error(
                    sample_id=sample_id,
                    domain=domain,
                    sample_text=text,
                    raw_response=response,
                    parsing_error=parsing_error,
                    validity_error=validity_error
                )

                print(f"\n⚠️  Malformed response for {sample_id} in {domain}")
                if parsing_error:
                    print(f"   Parsing: {parsing_error}")
                if validity_error:
                    print(f"   Validity: {validity_error}")

            # Write to sheet (even if malformed, for review)
            sheets_mgr.write_annotation(
                domain=domain,
                sample_id=sample_id,
                text=text,
                response=response,
                label=label if label else "MALFORMED",
                malformed_flag=malformed
            )

            # Mark as completed
            checkpoint_mgr.mark_completed(domain, sample_id)

            # Save checkpoint every 10 samples
            if (idx + 1) % 10 == 0:
                checkpoint_mgr.save()

            # Small delay to avoid rate limiting
            time.sleep(1)

        except Exception as e:
            if "RATE_LIMIT_HIT" in str(e):
                # Save checkpoint and exit
                checkpoint_mgr.save()
                print(f"\n💾 Checkpoint saved. Exiting...")
                exit()
            else:
                print(f"\n❌ Error processing {sample_id}: {str(e)}")
                continue

    # Final save
    checkpoint_mgr.save()

    print(f"\n✅ Domain '{domain}' annotation complete!\n")

print("✅ annotate_domain function defined")

"""# ────────────────────────────────────────────────────
# CELL 10: MAIN EXECUTION - RUN ANNOTATION
# ────────────────────────────────────────────────────
"""

# ═══════════════════════════════════════════════════════════
# INITIALIZE ALL MANAGERS
# ═══════════════════════════════════════════════════════════

print("\n" + "═"*70)
print("MENTAL HEALTH ANNOTATION SYSTEM - INITIALIZATION")
print("═"*70 + "\n")

# Create managers
checkpoint_mgr = CheckpointManager(ANNOTATOR_ID)
malform_logger = MalformLogger(ANNOTATOR_ID)
sheets_mgr = SheetsManager(gc, ANNOTATOR_ID)
gemini_client = GeminiAnnotator()

# Setup spreadsheet
spreadsheet = sheets_mgr.setup_spreadsheet()

# Load source data
samples_df = sheets_mgr.load_source_data()

print("\n" + "═"*70)
print(f"STARTING ANNOTATION FOR ANNOTATOR {ANNOTATOR_ID}")
print("═"*70 + "\n")

# ═══════════════════════════════════════════════════════════
# PROCESS EACH DOMAIN IN ORDER
# ═══════════════════════════════════════════════════════════

for domain in DOMAINS:
    try:
        annotate_domain(
            domain=domain,
            samples_df=samples_df,
            checkpoint_mgr=checkpoint_mgr,
            malform_logger=malform_logger,
            sheets_mgr=sheets_mgr,
            gemini_client=gemini_client
        )
    except Exception as e:
        print(f"\n❌ Fatal error in domain {domain}: {str(e)}")
        print("Saving checkpoint and stopping...")
        checkpoint_mgr.save()
        break

# ═══════════════════════════════════════════════════════════
# FINAL SUMMARY
# ═══════════════════════════════════════════════════════════

print("\n" + "═"*70)
print("ANNOTATION COMPLETE - SUMMARY")
print("═"*70 + "\n")

for domain in DOMAINS:
    completed, total = checkpoint_mgr.get_progress(domain, len(samples_df))
    status = "✅ Complete" if completed == total else f"⏳ {completed}/{total}"
    print(f"{domain:20s} {status}")

print("\n" + malform_logger.get_summary())

print("\n" + "═"*70)
print(f"Spreadsheet URL: {spreadsheet.url}")
print(f"Checkpoint saved: {checkpoint_mgr.checkpoint_path}")
print(f"Malform log saved: {malform_logger.log_path}")
print("═"*70 + "\n")

